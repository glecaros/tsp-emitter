package modeltest

import "encoding/json"

// This file is generated by the typespec compiler. Do not edit.
type SmallBox struct {
}

func (m SmallBox) Type() string {
	return "small"
}

func (m *SmallBox) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return nil
}

func (m SmallBox) MarshalJSON() ([]byte, error) {
	obj := map[string]interface{}{
		"type": "small",
	}

	return json.Marshal(obj)
}

type LargeBox struct {
}

func (m LargeBox) Type() string {
	return "large"
}

func (m *LargeBox) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return nil
}

func (m LargeBox) MarshalJSON() ([]byte, error) {
	obj := map[string]interface{}{
		"type": "large",
	}

	return json.Marshal(obj)
}

type Box interface {
	Type() string
}

func UnmarshalBox(data []byte) (Box, error) {
	var typeCheck struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &typeCheck); err != nil {
		return nil, err
	}

	var result Box
	switch typeCheck.Type {
	case "small":
		var v SmallBox
		if err := json.Unmarshal(data, &v); err != nil {
			return nil, err
		}
		result = v

	case "large":
		var v LargeBox
		if err := json.Unmarshal(data, &v); err != nil {
			return nil, err
		}
		result = v

	}
	return result, nil
}

type Storage struct {
	Box Box
}

func (m *Storage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	if v, ok := rawMsg["box"]; ok {
		if err := json.Unmarshal(v, &m.Box); err != nil {
			return err
		}
	}
	return nil
}

func (m Storage) MarshalJSON() ([]byte, error) {
	obj := map[string]interface{}{
		"box": m.Box,
	}

	return json.Marshal(obj)
}
