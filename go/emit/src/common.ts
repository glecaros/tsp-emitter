import { DecoratorApplication, DecoratorArgument, Scalar } from "@typespec/compiler";

export function stripIndent(
  strings: TemplateStringsArray,
  ...values: any[]
): string {
  const fullString = strings
    .reduce((acc, str, i) => acc + str + (values[i] || ""), "")
    .replace(/^\n+/g, "");

  const match = fullString.match(/^[ \t]*(?=\S)/gm);
  if (!match) return fullString;

  const indent = Math.min(...match.map((el) => el.length));
  const regex = new RegExp(`^[ \\t]{${indent}}`, "gm");

  return indent > 0 ? fullString.replace(regex, "") : fullString;
}

export function emitHeader(packageName: string, imports: string[]): string {
  return stripIndent`
        package ${packageName}
        ${imports
          .map(
            (i) => `
        import \"${i}\"`,
          )
          .join("\n")}

        // This file is generated by the typespec compiler. Do not edit.`;
}

export type Optional<T> = T | undefined;

interface Decorated {
  decorators: DecoratorApplication[];
}

function getDecoratorArgs(
  element: Decorated,
  decoratorName: string,
): DecoratorArgument[][] {
  return element.decorators
    .filter((d) => d.definition?.name === decoratorName)
    .map((d) => d.args);
}

function getDecoratorArg(
  element: Decorated,
  decoratorName: string,
  predicate: (args: DecoratorArgument[]) => boolean,
): DecoratorArgument[] | undefined {
  const filtered = getDecoratorArgs(element, decoratorName).filter(predicate);
  if (filtered.length === 0) {
    return undefined;
  }
  return filtered[0];
}

export function getDoc(element: Decorated): Optional<string> {
  const docDecorator = getDecoratorArg(
    element,
    "@doc",
    (args) => args.length === 1,
  );
  return docDecorator?.at(0)?.jsValue?.toString();
}

export function getEncodedName(
  element: Decorated,
  mimeType: string,
): Optional<string> {
  const encodedName = getDecoratorArg(
    element,
    "@encodedName",
    (args) => args.length === 2 && args[0].jsValue === mimeType,
  );
  return encodedName?.at(1)?.jsValue as Optional<string>;
}


function mapScalarToGoType(scalar: Scalar): string {
    const scalarMap: Record<string, string> = {
      string: "string",
      int32: "int32",
      int64: "int64",
      integer: "int64",
      float32: "float32",
      float64: "float64",
      boolean: "bool",
      date: "time.Time",
      datetime: "time.Time",
      duration: "time.Duration",
      uuid: "string",
      url: "string",
      email: "string",
    };
    if (scalarMap[scalar.name] === undefined) {
      throw new Error(`Unsupported scalar type: ${scalar.name}`);
    }

    return scalarMap[scalar.name];
  }